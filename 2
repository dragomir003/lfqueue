#include <atomic>
#include <memory>

#include <thread>
#include <algorithm>
#include <vector>
#include <array>
#include <iostream>

template <typename T>
struct Channel {
private:

    struct node
    {
        std::shared_ptr<T> data;
        std::atomic<node*> next;
        node(T const& data_):
            data(std::make_shared<T>(data_))
        {}
        node()
            : data(nullptr), next(nullptr) {}
    };
    std::atomic<node*> head;
    std::atomic<node*> tail;

public:

    using value_type = T;
    using pointer_type = std::shared_ptr<T>;

    Channel()
        : head(new node), tail(head.load()) {}

    void push(T const& data)
    {
        std::atomic<node*> const new_node=new node(data);
        node* null_node = nullptr;

        node* old_tail = tail.load();
        while(!old_tail->next.compare_exchange_weak(null_node, new_node)){
          old_tail = tail.load();
        }
        tail.compare_exchange_weak(old_tail, new_node);
    }

    std::shared_ptr<T> pop()
    {
        node* old_head=head.load();
        while(old_head &&
            !head.compare_exchange_weak(old_head,old_head->next)){
            old_head=head.load();
        }
        return old_head ? old_head->data : std::shared_ptr<T>();
    }

};

auto main(int argc, char* argv[]) -> int {

    std::array<int, 16> array{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };

    using IndexType = std::uint16_t;
    Channel<int> channel;

    std::vector<bool> dones;
    std::vector<std::thread> writers;

    const auto func = [&channel, &array, &dones](int idx) {
        for (int i = 0; i < (idx + 1) * 10; ++i)
            for (const auto elem : array)
                channel.push(elem);
        dones[idx] = true;
    };

    const int num_writers = argc > 1 ? std::atoi(argv[1]) : 3;
    for (int i = 0; i < num_writers; ++i) {
        writers.emplace_back(func, i);
        writers.back().detach();
        dones.emplace_back(false);
    }

    const auto is_filled = [&dones] {
        return std::count(begin(dones), end(dones), true) == dones.size();
    };

    std::uintmax_t total = 0;
    while (true) {
        auto value = channel.pop();

        if (!value && is_filled())
            break;
        if (!value)
            continue;

        ++total;

        std::cout << "Got(" << total << ") " << *value << '@' << value << '\r' << std::flush;
    }
    std::cout << '\n';
}
